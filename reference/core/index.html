
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Documentation for pyRho">
      
      
      
      
        <link rel="canonical" href="https://materialsproject.github.io/pyrho/reference/core/">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-7.0.3">
    
    
      
        <title>core - PyRho Documentation</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.1655a90d.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.7fa14f5b.min.css">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
      <link rel="stylesheet" href="../../assets/_mkdocstrings.css">
    
    
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
      
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#pyrho.core.pgrid" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="https://materialsproject.github.io/pyrho/" title="PyRho Documentation" class="md-header__button md-logo" aria-label="PyRho Documentation">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            PyRho Documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              core
            
          </span>
        </div>
      </div>
    </div>
    <div class="md-header__options">
      
    </div>
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        
<a href="https://github.com/materialsproject/pyrho/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    




<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="https://materialsproject.github.io/pyrho/" title="PyRho Documentation" class="md-nav__button md-logo" aria-label="PyRho Documentation">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    PyRho Documentation
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/materialsproject/pyrho/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../concepts/" class="md-nav__link">
        Core Concepts
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" >
      
      <label class="md-nav__link" for="__nav_3">
        Getting Started
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="Getting Started" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          Getting Started
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../getting_started/jupyter_setup/" class="md-nav__link">
        Jupyter Setup
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4" type="checkbox" id="__nav_4" checked>
      
      <label class="md-nav__link" for="__nav_4">
        Reference
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="Reference" data-md-level="1">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          Reference
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          core
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        core
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pyrho.core.pgrid" class="md-nav__link">
    pyrho.core.pgrid
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pyrho.core.pgrid.PGrid" class="md-nav__link">
    PGrid
  </a>
  
    <nav class="md-nav" aria-label="PGrid">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pyrho.core.pgrid.PGrid.__init__" class="md-nav__link">
    __init__()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.pgrid.PGrid.gaussian_smear" class="md-nav__link">
    gaussian_smear()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.pgrid.PGrid.get_transformed_data" class="md-nav__link">
    get_transformed_data()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.pgrid.PGrid.get_transformed_obj" class="md-nav__link">
    get_transformed_obj()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.pgrid.PGrid.lossy_smooth_compression" class="md-nav__link">
    lossy_smooth_compression()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pyrho.core.fourier" class="md-nav__link">
    pyrho.core.fourier
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pyrho.core.fourier.PFourier" class="md-nav__link">
    PFourier
  </a>
  
    <nav class="md-nav" aria-label="PFourier">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pyrho.core.fourier.PFourier.cartesian_reciprocal_pos" class="md-nav__link">
    cartesian_reciprocal_pos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.fourier.PFourier.fft_pos_centered" class="md-nav__link">
    fft_pos_centered
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.fourier.PFourier.fft_pos_centered_cartesian" class="md-nav__link">
    fft_pos_centered_cartesian
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.fourier.PFourier.fft_pos_centered_cartesian_s" class="md-nav__link">
    fft_pos_centered_cartesian_s
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.fourier.PFourier.fft_pos_centered_s" class="md-nav__link">
    fft_pos_centered_s
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.fourier.PFourier.fractional_reciprocal_pos" class="md-nav__link">
    fractional_reciprocal_pos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.fourier.PFourier.reciprocal_lattice" class="md-nav__link">
    reciprocal_lattice
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.fourier.PFourier.__init__" class="md-nav__link">
    __init__()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.fourier.PFourier.get_points_dict" class="md-nav__link">
    get_points_dict()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pyrho.core.chargeDensity" class="md-nav__link">
    pyrho.core.chargeDensity
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pyrho.core.chargeDensity.ChargeDensity" class="md-nav__link">
    ChargeDensity
  </a>
  
    <nav class="md-nav" aria-label="ChargeDensity">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pyrho.core.chargeDensity.ChargeDensity.lattice" class="md-nav__link">
    lattice
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.chargeDensity.ChargeDensity.rho" class="md-nav__link">
    rho
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.chargeDensity.ChargeDensity.__init__" class="md-nav__link">
    __init__()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.chargeDensity.ChargeDensity.from_pmg_volumetric_data" class="md-nav__link">
    from_pmg_volumetric_data()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.chargeDensity.ChargeDensity.get_transformed_obj" class="md-nav__link">
    get_transformed_obj()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.chargeDensity.ChargeDensity.reorient_axis" class="md-nav__link">
    reorient_axis()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pyrho.core.chargeDensity.SpinChargeDensity" class="md-nav__link">
    SpinChargeDensity
  </a>
  
    <nav class="md-nav" aria-label="SpinChargeDensity">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pyrho.core.chargeDensity.SpinChargeDensity.__init__" class="md-nav__link">
    __init__()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pyrho.core.chargeDensity.multiply_aug" class="md-nav__link">
    multiply_aug()
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../vis/" class="md-nav__link">
        vis
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../CHANGELOG/" class="md-nav__link">
        Changelog
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pyrho.core.pgrid" class="md-nav__link">
    pyrho.core.pgrid
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pyrho.core.pgrid.PGrid" class="md-nav__link">
    PGrid
  </a>
  
    <nav class="md-nav" aria-label="PGrid">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pyrho.core.pgrid.PGrid.__init__" class="md-nav__link">
    __init__()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.pgrid.PGrid.gaussian_smear" class="md-nav__link">
    gaussian_smear()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.pgrid.PGrid.get_transformed_data" class="md-nav__link">
    get_transformed_data()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.pgrid.PGrid.get_transformed_obj" class="md-nav__link">
    get_transformed_obj()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.pgrid.PGrid.lossy_smooth_compression" class="md-nav__link">
    lossy_smooth_compression()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pyrho.core.fourier" class="md-nav__link">
    pyrho.core.fourier
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pyrho.core.fourier.PFourier" class="md-nav__link">
    PFourier
  </a>
  
    <nav class="md-nav" aria-label="PFourier">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pyrho.core.fourier.PFourier.cartesian_reciprocal_pos" class="md-nav__link">
    cartesian_reciprocal_pos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.fourier.PFourier.fft_pos_centered" class="md-nav__link">
    fft_pos_centered
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.fourier.PFourier.fft_pos_centered_cartesian" class="md-nav__link">
    fft_pos_centered_cartesian
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.fourier.PFourier.fft_pos_centered_cartesian_s" class="md-nav__link">
    fft_pos_centered_cartesian_s
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.fourier.PFourier.fft_pos_centered_s" class="md-nav__link">
    fft_pos_centered_s
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.fourier.PFourier.fractional_reciprocal_pos" class="md-nav__link">
    fractional_reciprocal_pos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.fourier.PFourier.reciprocal_lattice" class="md-nav__link">
    reciprocal_lattice
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.fourier.PFourier.__init__" class="md-nav__link">
    __init__()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.fourier.PFourier.get_points_dict" class="md-nav__link">
    get_points_dict()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pyrho.core.chargeDensity" class="md-nav__link">
    pyrho.core.chargeDensity
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pyrho.core.chargeDensity.ChargeDensity" class="md-nav__link">
    ChargeDensity
  </a>
  
    <nav class="md-nav" aria-label="ChargeDensity">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pyrho.core.chargeDensity.ChargeDensity.lattice" class="md-nav__link">
    lattice
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.chargeDensity.ChargeDensity.rho" class="md-nav__link">
    rho
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.chargeDensity.ChargeDensity.__init__" class="md-nav__link">
    __init__()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.chargeDensity.ChargeDensity.from_pmg_volumetric_data" class="md-nav__link">
    from_pmg_volumetric_data()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.chargeDensity.ChargeDensity.get_transformed_obj" class="md-nav__link">
    get_transformed_obj()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pyrho.core.chargeDensity.ChargeDensity.reorient_axis" class="md-nav__link">
    reorient_axis()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pyrho.core.chargeDensity.SpinChargeDensity" class="md-nav__link">
    SpinChargeDensity
  </a>
  
    <nav class="md-nav" aria-label="SpinChargeDensity">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pyrho.core.chargeDensity.SpinChargeDensity.__init__" class="md-nav__link">
    __init__()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pyrho.core.chargeDensity.multiply_aug" class="md-nav__link">
    multiply_aug()
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/materialsproject/pyrho/edit/master/docs/reference/core.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                  <h1>core</h1>
                
                <div class="doc doc-object doc-module">

<a id="pyrho.core.pgrid"></a>
    <div class="doc doc-contents first">

      <p>Python class for ND grid data volumetric data</p>



  <div class="doc doc-children">







  <div class="doc doc-object doc-class">



<h2 id="pyrho.core.pgrid.PGrid" class="doc doc-heading">
        <code>PGrid</code>



<a href="#pyrho.core.pgrid.PGrid" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">





  <div class="doc doc-children">









  <div class="doc doc-object doc-method">



<h3 id="pyrho.core.pgrid.PGrid.__init__" class="doc doc-heading">
<code class="codehilite language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_data</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#pyrho.core.pgrid.PGrid.__init__" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Base class for N-dimensional Regular period grid data.
The core code should be valid in N-dimensions and not depend on pymatgen</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>grid_data</code></td>
        <td><code>ndarray</code></td>
        <td><p>Data stored on the regular rid</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>lattice</code></td>
        <td><code>Optional[numpy.ndarray]</code></td>
        <td><p>list of lattice vectors</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>pyrho/core/pgrid.py</code></summary>
          <div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">lattice</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for N-dimensional Regular period grid data.</span>
<span class="sd">    The core code should be valid in N-dimensions and not depend on pymatgen</span>

<span class="sd">    Args:</span>
<span class="sd">        grid_data: Data stored on the regular rid</span>
<span class="sd">        lattice: list of lattice vectors</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">lattice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lattice</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">grid_data</span> <span class="o">=</span> <span class="n">grid_data</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">grid_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_data</span><span class="o">.</span><span class="n">shape</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ngridpts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_shape</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="pyrho.core.pgrid.PGrid.gaussian_smear" class="doc doc-heading">
<code class="codehilite language-python"><span class="n">gaussian_smear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">arr_in</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#pyrho.core.pgrid.PGrid.gaussian_smear" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Applies an isotropic Gaussian smear of width (standard deviation) r to
the potential field. This is necessary to avoid finding paths through
narrow minima or nodes that may exist in the field (although any
potential or charge distribution generated from GGA should be
relatively smooth anyway). The smearing obeys periodic
boundary conditions at the edges of the cell.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>sigma</code></td>
        <td><code>float</code></td>
        <td><p>Smearing width in cartesian coordinates, in the same units as the</p></td>
        <td><code>0.2</code></td>
      </tr>
      <tr>
        <td><code>arr_in</code></td>
        <td><code>ndarray</code></td>
        <td><p>input data array to smear, if None: smear self.grid_data</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>pyrho/core/pgrid.py</code></summary>
          <div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">gaussian_smear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">arr_in</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies an isotropic Gaussian smear of width (standard deviation) r to</span>
<span class="sd">    the potential field. This is necessary to avoid finding paths through</span>
<span class="sd">    narrow minima or nodes that may exist in the field (although any</span>
<span class="sd">    potential or charge distribution generated from GGA should be</span>
<span class="sd">    relatively smooth anyway). The smearing obeys periodic</span>
<span class="sd">    boundary conditions at the edges of the cell.</span>

<span class="sd">    Args:</span>
<span class="sd">        sigma: Smearing width in cartesian coordinates, in the same units as the</span>
<span class="sd">        structure lattice vectors</span>
<span class="sd">        arr_in: input data array to smear, if None: smear self.grid_data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get the dimension of the filter needed for 1 std dev of gaussian mask</span>
    <span class="c1"># Go 4 standard deviations away</span>
    <span class="k">if</span> <span class="n">arr_in</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">arr_in</span>
    <span class="n">r_frac</span> <span class="o">=</span> <span class="n">get_ucell_frac_fit_sphere</span><span class="p">(</span><span class="n">lattice</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">sigma</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">filter_shape</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">itr_rf</span> <span class="o">*</span> <span class="n">itr_dim</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># dimension of the filter should be even</span>
        <span class="k">for</span> <span class="n">itr_rf</span><span class="p">,</span> <span class="n">itr_dim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">r_frac</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="n">filter_latt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">filter_shape</span><span class="p">[</span><span class="n">_</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">_</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">[</span><span class="n">_</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim</span><span class="p">)])</span>

    <span class="c1"># Get the fractional positions</span>
    <span class="n">filter_frac_c</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">filter_shape</span><span class="p">]</span>
    <span class="n">frac_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">filter_frac_c</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s2">&quot;ij&quot;</span><span class="p">)</span>
    <span class="n">frac_pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">frac_pos</span><span class="p">]</span>

    <span class="c1"># convert to cartesian</span>
    <span class="n">cart_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">filter_latt</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">frac_pos</span><span class="p">))</span>

    <span class="c1"># Distance the center if 1d we make  this iterable</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">filter_latt</span><span class="p">)</span>  <span class="c1"># type: Union[float, np.ndarray]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">mid_point</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># type: Union[List, np.ndarray]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mid_point</span> <span class="o">=</span> <span class="p">[</span><span class="n">tmp</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">disp2mid2</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i_coord</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">filter_shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">mp_coord</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">mp_coord</span><span class="p">,</span> <span class="n">i_coord</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mid_point</span><span class="p">,</span> <span class="n">cart_pos</span><span class="p">)]</span>
    <span class="n">dist2mid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">disp2mid2</span><span class="p">))</span>
    <span class="c1"># make sure the mask is zero?</span>
    <span class="n">mm</span> <span class="o">=</span> <span class="n">dist2mid</span> <span class="o">&lt;=</span> <span class="n">sigma</span> <span class="o">*</span> <span class="mi">4</span>
    <span class="n">gauss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">dist2mid</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">mm</span>
    <span class="n">gauss</span> <span class="o">=</span> <span class="n">gauss</span> <span class="o">/</span> <span class="n">gauss</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">convolve</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">arr</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">gauss</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;wrap&quot;</span><span class="p">),</span> <span class="n">gauss</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="pyrho.core.pgrid.PGrid.get_transformed_data" class="doc doc-heading">
<code class="codehilite language-python"><span class="n">get_transformed_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sc_mat</span><span class="p">,</span> <span class="n">frac_shift</span><span class="p">,</span> <span class="n">grid_out</span><span class="p">,</span> <span class="n">up_sample</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></code>


<a href="#pyrho.core.pgrid.PGrid.get_transformed_data" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Apply a transformation to the grid data
This function assumes that the data is fixed in place and the transformation
is applied to the lattice vectors.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>sc_mat</code></td>
        <td><code>Union[int, float, complex, str, bytes, numpy.generic, Sequence[Union[int, float, complex, str, bytes, numpy.generic]], Sequence[Sequence[Any]], numpy._array_like._SupportsArray]</code></td>
        <td><p>matrix transformation applied to the lattice vectors</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>frac_shift</code></td>
        <td><code>Union[int, float, complex, str, bytes, numpy.generic, Sequence[Union[int, float, complex, str, bytes, numpy.generic]], Sequence[Sequence[Any]], numpy._array_like._SupportsArray]</code></td>
        <td><p>shift the lattice in fractional coordinates of the input cell</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>up_sample</code></td>
        <td><code>int</code></td>
        <td><p>the factor to scale up the sampling of the grid data</p></td>
        <td><code>1</code></td>
      </tr>
  </tbody>
</table>      <p>sc_mat  ---&gt;  [2, 1]    trans  ---&gt;  [0.1, 0.3]
              [0, 1]
new lattice vectors:
    a = [0.2, 0.4] --&gt; [2.2, 1.4]
    b = [0.2, 0.4] --&gt; [0.2, 1.1]</p>

<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>ndarray</code></td>
      <td><p>transformed data</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>pyrho/core/pgrid.py</code></summary>
          <div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">get_transformed_data</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">sc_mat</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="n">frac_shift</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="n">grid_out</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">up_sample</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a transformation to the grid data</span>
<span class="sd">    This function assumes that the data is fixed in place and the transformation</span>
<span class="sd">    is applied to the lattice vectors.</span>
<span class="sd">    Args:</span>
<span class="sd">        sc_mat: matrix transformation applied to the lattice vectors</span>
<span class="sd">        frac_shift: shift the lattice in fractional coordinates of the input cell</span>
<span class="sd">        up_sample: the factor to scale up the sampling of the grid data</span>

<span class="sd">    sc_mat  ---&gt;  [2, 1]    trans  ---&gt;  [0.1, 0.3]</span>
<span class="sd">                  [0, 1]</span>
<span class="sd">    new lattice vectors:</span>
<span class="sd">        a = [0.2, 0.4] --&gt; [2.2, 1.4]</span>
<span class="sd">        b = [0.2, 0.4] --&gt; [0.2, 1.1]</span>

<span class="sd">    Returns:</span>
<span class="sd">        transformed data</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">up_sample</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">interp_grid_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">interp_grid_data</span> <span class="o">=</span> <span class="n">interpolate_fourier</span><span class="p">(</span>
            <span class="n">arr_in</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_data</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="n">g_dim_</span> <span class="o">*</span> <span class="n">up_sample</span> <span class="k">for</span> <span class="n">g_dim_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_data</span><span class="o">.</span><span class="n">shape</span><span class="p">],</span>
        <span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">new_rho</span> <span class="o">=</span> <span class="n">get_sc_interp</span><span class="p">(</span><span class="n">interp_grid_data</span><span class="p">,</span> <span class="n">sc_mat</span><span class="p">,</span> <span class="n">grid_sizes</span><span class="o">=</span><span class="n">grid_out</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">frac_shift</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
    <span class="n">new_rho</span> <span class="o">=</span> <span class="n">new_rho</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">grid_out</span><span class="p">)</span>

    <span class="c1"># TODO make this part of the original transformation</span>
    <span class="c1"># grid_shifts = [</span>
    <span class="c1">#     int(t * g) for t, g in zip(frac_shift - np.round(frac_shift), grid_out)</span>
    <span class="c1"># ]</span>
    <span class="c1">#</span>
    <span class="c1"># new_rho = roll_array(new_rho, grid_shifts)</span>

    <span class="k">return</span> <span class="n">new_rho</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="pyrho.core.pgrid.PGrid.get_transformed_obj" class="doc doc-heading">
<code class="codehilite language-python"><span class="n">get_transformed_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sc_mat</span><span class="p">,</span> <span class="n">frac_shift</span><span class="p">,</span> <span class="n">grid_out</span><span class="p">,</span> <span class="n">up_sample</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></code>


<a href="#pyrho.core.pgrid.PGrid.get_transformed_obj" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Get a new PGrid object for the new transformed data</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>sc_mat</code></td>
        <td><code>Union[List[List[int]], numpy.ndarray]</code></td>
        <td><p>matrix transformation applied to the lattice vectors</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>frac_shift</code></td>
        <td><code>Union[numpy.ndarray, List[float], Tuple[float]]</code></td>
        <td><p>shift the lattice in fractional coordinates of the output cell</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>grid_out</code></td>
        <td><code>List[int]</code></td>
        <td><p>The size of the output grid to interpolate on</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>up_sample</code></td>
        <td><code>int</code></td>
        <td><p>the factor to scale up the sampling of the grid data</p></td>
        <td><code>1</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>PGrid</code></td>
      <td><p>New PGrid object</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>pyrho/core/pgrid.py</code></summary>
          <div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">get_transformed_obj</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">sc_mat</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">frac_shift</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span>
    <span class="n">grid_out</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">up_sample</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;PGrid&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get a new PGrid object for the new transformed data</span>
<span class="sd">    Args:</span>
<span class="sd">        sc_mat: matrix transformation applied to the lattice vectors</span>
<span class="sd">        frac_shift: shift the lattice in fractional coordinates of the output cell</span>
<span class="sd">        grid_out: The size of the output grid to interpolate on</span>
<span class="sd">        up_sample: the factor to scale up the sampling of the grid data</span>

<span class="sd">    Returns:</span>
<span class="sd">        New PGrid object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transformed_data</span><span class="p">(</span><span class="n">sc_mat</span><span class="p">,</span> <span class="n">frac_shift</span><span class="p">,</span> <span class="n">grid_out</span><span class="o">=</span><span class="n">grid_out</span><span class="p">,</span> <span class="n">up_sample</span><span class="o">=</span><span class="n">up_sample</span><span class="p">)</span>
    <span class="n">new_lattice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sc_mat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">PGrid</span><span class="p">(</span><span class="n">grid_data</span><span class="o">=</span><span class="n">new_data</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="n">new_lattice</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="pyrho.core.pgrid.PGrid.lossy_smooth_compression" class="doc doc-heading">
<code class="codehilite language-python"><span class="n">lossy_smooth_compression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_out</span><span class="p">,</span> <span class="n">smear_std</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span></code>


<a href="#pyrho.core.pgrid.PGrid.lossy_smooth_compression" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Perform Fourier interpolation then Gaussian smoothing.
the smoothing makes sure that simple operation like max and min filters still
give the same results.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>grid_out</code></td>
        <td><code>List</code></td>
        <td><p>desired output grid of the compressed data,</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>ndarray</code></td>
      <td><p>Smoothed array</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>pyrho/core/pgrid.py</code></summary>
          <div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">lossy_smooth_compression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_out</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span> <span class="n">smear_std</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform Fourier interpolation then Gaussian smoothing.</span>
<span class="sd">    the smoothing makes sure that simple operation like max and min filters still</span>
<span class="sd">    give the same results.</span>

<span class="sd">    Args:</span>
<span class="sd">        grid_out: desired output grid of the compressed data,</span>

<span class="sd">    Returns:</span>
<span class="sd">        Smoothed array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arr_interp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">interpolate_fourier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_data</span><span class="p">,</span> <span class="n">grid_out</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">smear_std</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">arr_interp</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_smear</span><span class="p">(</span><span class="n">arr_in</span><span class="o">=</span><span class="n">arr_interp</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">smear_std</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">arr_interp</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>







  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">

<a id="pyrho.core.fourier"></a>
    <div class="doc doc-contents first">

      <p>Fourier analysis functions.</p>



  <div class="doc doc-children">







  <div class="doc doc-object doc-class">



<h2 id="pyrho.core.fourier.PFourier" class="doc doc-heading">
        <code>PFourier</code>



<a href="#pyrho.core.fourier.PFourier" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">





  <div class="doc doc-children">






  <div class="doc doc-object doc-attribute">



<h3 id="pyrho.core.fourier.PFourier.cartesian_reciprocal_pos" class="doc doc-heading">
<code class="codehilite language-python"><span class="n">cartesian_reciprocal_pos</span><span class="p">:</span> <span class="n">ndarray</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-property"><code>property</code></small>
      <small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
  </span>

<a href="#pyrho.core.fourier.PFourier.cartesian_reciprocal_pos" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Get the list of reciprocal lattice points in cartesian coordinates</p>
    </div>

  </div>



  <div class="doc doc-object doc-attribute">



<h3 id="pyrho.core.fourier.PFourier.fft_pos_centered" class="doc doc-heading">
<code class="codehilite language-python"><span class="n">fft_pos_centered</span><span class="p">:</span> <span class="n">ndarray</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-property"><code>property</code></small>
      <small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
  </span>

<a href="#pyrho.core.fourier.PFourier.fft_pos_centered" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Return the fft positions where the N-k is changed to -k</p>
    </div>

  </div>



  <div class="doc doc-object doc-attribute">



<h3 id="pyrho.core.fourier.PFourier.fft_pos_centered_cartesian" class="doc doc-heading">
<code class="codehilite language-python"><span class="n">fft_pos_centered_cartesian</span><span class="p">:</span> <span class="n">List</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-property"><code>property</code></small>
      <small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
  </span>

<a href="#pyrho.core.fourier.PFourier.fft_pos_centered_cartesian" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Return the fft positions where the N-k is changed to -k</p>
    </div>

  </div>



  <div class="doc doc-object doc-attribute">



<h3 id="pyrho.core.fourier.PFourier.fft_pos_centered_cartesian_s" class="doc doc-heading">
<code class="codehilite language-python"><span class="n">fft_pos_centered_cartesian_s</span><span class="p">:</span> <span class="n">List</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-property"><code>property</code></small>
      <small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
  </span>

<a href="#pyrho.core.fourier.PFourier.fft_pos_centered_cartesian_s" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Return the fft positions where the N-k is changed to -k</p>
    </div>

  </div>



  <div class="doc doc-object doc-attribute">



<h3 id="pyrho.core.fourier.PFourier.fft_pos_centered_s" class="doc doc-heading">
<code class="codehilite language-python"><span class="n">fft_pos_centered_s</span><span class="p">:</span> <span class="n">ndarray</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-property"><code>property</code></small>
      <small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
  </span>

<a href="#pyrho.core.fourier.PFourier.fft_pos_centered_s" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Return the fft positions where the N-k is changed to -k</p>
    </div>

  </div>



  <div class="doc doc-object doc-attribute">



<h3 id="pyrho.core.fourier.PFourier.fractional_reciprocal_pos" class="doc doc-heading">
<code class="codehilite language-python"><span class="n">fractional_reciprocal_pos</span><span class="p">:</span> <span class="n">ndarray</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-property"><code>property</code></small>
      <small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
  </span>

<a href="#pyrho.core.fourier.PFourier.fractional_reciprocal_pos" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Return fft position  structured grid
Assuming standard fft format A[N-1] = A[-1]</p>
    </div>

  </div>



  <div class="doc doc-object doc-attribute">



<h3 id="pyrho.core.fourier.PFourier.reciprocal_lattice" class="doc doc-heading">
<code class="codehilite language-python"><span class="n">reciprocal_lattice</span><span class="p">:</span> <span class="n">ndarray</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-property"><code>property</code></small>
      <small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
  </span>

<a href="#pyrho.core.fourier.PFourier.reciprocal_lattice" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Return the reciprocal lattice. Note that this is the standard
reciprocal lattice used for solid state physics with a factor of 2 *
pi.</p>
    </div>

  </div>






  <div class="doc doc-object doc-method">



<h3 id="pyrho.core.fourier.PFourier.__init__" class="doc doc-heading">
<code class="codehilite language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fourier_data</span><span class="p">,</span> <span class="n">lattice</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#pyrho.core.fourier.PFourier.__init__" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Fourier transform defined for a periodic function. The representation must be
SC agnostic, (i.e. if we double the size of the unit cell)</p>
<p>Much of the analysis relies on the fact that numpy.ndarray.flatten puts the array in a particular order.
The correct ordering is used but not strictly enforced by the present code so use with care.
Also make sure the fourier data is generated in the correct way: with index='ij'</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>fourier_data</code></td>
        <td><code>ndarray</code></td>
        <td><p>Complex data for each point in fourier_pos</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>lattice</code></td>
        <td><code>Union[int, float, complex, str, bytes, numpy.generic, Sequence[Union[int, float, complex, str, bytes, numpy.generic]], Sequence[Sequence[Any]], numpy._array_like._SupportsArray]</code></td>
        <td><p>The corresponding real space lattice parameters</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>pyrho/core/fourier.py</code></summary>
          <div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fourier_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">lattice</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fourier transform defined for a periodic function. The representation must be</span>
<span class="sd">    SC agnostic, (i.e. if we double the size of the unit cell)</span>

<span class="sd">    Much of the analysis relies on the fact that numpy.ndarray.flatten puts the array in a particular order.</span>
<span class="sd">    The correct ordering is used but not strictly enforced by the present code so use with care.</span>
<span class="sd">    Also make sure the fourier data is generated in the correct way: with index=&#39;ij&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        fourier_data: Complex data for each point in fourier_pos</span>
<span class="sd">        lattice: The corresponding real space lattice parameters</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lattice</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">fourier_data</span> <span class="o">=</span> <span class="n">fourier_data</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">fourier_data</span><span class="o">.</span><span class="n">shape</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="pyrho.core.fourier.PFourier.get_points_dict" class="doc doc-heading">
<code class="codehilite language-python"><span class="n">get_points_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_val</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a href="#pyrho.core.fourier.PFourier.get_points_dict" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Return filtered data as a (position, fft_coefficient) pair</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>filter_val</code></td>
        <td><code>Callable</code></td>
        <td><p>Filter function applied to the fourier data values (Example: Only keep large Fourier weights)</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>ftiler_pos</code></td>
        <td><code></code></td>
        <td><p>Filter function applied to the reciprocal positions (Example: low pass filter)</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>pyrho/core/fourier.py</code></summary>
          <div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">get_points_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_pos</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">filter_val</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return filtered data as a (position, fft_coefficient) pair</span>
<span class="sd">    Args:</span>
<span class="sd">        filter_val: Filter function applied to the fourier data values (Example: Only keep large Fourier weights)</span>
<span class="sd">        ftiler_pos: Filter function applied to the reciprocal positions (Example: low pass filter)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">cart_pos</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cartesian_reciprocal_pos</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fourier_data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()):</span>
        <span class="k">if</span> <span class="n">filter_val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">filter_val</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">filter_pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">filter_pos</span><span class="p">(</span><span class="n">cart_pos</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="k">yield</span> <span class="n">cart_pos</span><span class="p">,</span> <span class="n">val</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>







  </div>

    </div>

  </div>



  <div class="doc doc-object doc-module">

<a id="pyrho.core.chargeDensity"></a>
    <div class="doc doc-contents first">

      <p>Chang Density Objects: Periodic Grid + Lattice / Atoms</p>



  <div class="doc doc-children">








  <div class="doc doc-object doc-class">



<h2 id="pyrho.core.chargeDensity.ChargeDensity" class="doc doc-heading">
        <code>ChargeDensity</code>



<a href="#pyrho.core.chargeDensity.ChargeDensity" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">





  <div class="doc doc-children">






  <div class="doc doc-object doc-attribute">



<h3 id="pyrho.core.chargeDensity.ChargeDensity.lattice" class="doc doc-heading">
<code class="codehilite language-python"><span class="n">lattice</span><span class="p">:</span> <span class="n">ndarray</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-property"><code>property</code></small>
      <small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
  </span>

<a href="#pyrho.core.chargeDensity.ChargeDensity.lattice" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Override the lattice definition in PGrid, this makes getting the reoriented charge density easier.</p>
    </div>

  </div>




  <div class="doc doc-object doc-attribute">



<h3 id="pyrho.core.chargeDensity.ChargeDensity.rho" class="doc doc-heading">
<code class="codehilite language-python"><span class="n">rho</span><span class="p">:</span> <span class="n">ndarray</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-property"><code>property</code></small>
      <small class="doc doc-property doc-property-readonly"><code>readonly</code></small>
  </span>

<a href="#pyrho.core.chargeDensity.ChargeDensity.rho" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Alias for the grid data, which should be the true charge density</p>
    </div>

  </div>






  <div class="doc doc-object doc-method">



<h3 id="pyrho.core.chargeDensity.ChargeDensity.__init__" class="doc doc-heading">
<code class="codehilite language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_data</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">normalization</span><span class="o">=</span><span class="s1">&#39;vasp&#39;</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#pyrho.core.chargeDensity.ChargeDensity.__init__" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Class that contains functions to featurize volumetic data with periodic
boundary conditions.
Make sure the data being stored is grid-independent</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>grid_data</code></td>
        <td><code>ndarray</code></td>
        <td><p>Volumetric data to read in</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>structure</code></td>
        <td><code>Structure</code></td>
        <td><p>Atomic structure corresponding to the charge density</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>normalization</code></td>
        <td><code>str</code></td>
        <td><p>the normalization scheme:
- 'vasp' sum of the data / number of grid points == number of electrons</p></td>
        <td><code>&#39;vasp&#39;</code></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>pyrho/core/chargeDensity.py</code></summary>
          <div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">grid_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">structure</span><span class="p">:</span> <span class="n">Structure</span><span class="p">,</span>
    <span class="n">normalization</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;vasp&quot;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class that contains functions to featurize volumetic data with periodic</span>
<span class="sd">    boundary conditions.</span>
<span class="sd">    Make sure the data being stored is grid-independent</span>

<span class="sd">    Args:</span>
<span class="sd">        grid_data: Volumetric data to read in</span>
<span class="sd">        structure: Atomic structure corresponding to the charge density</span>
<span class="sd">        normalization: the normalization scheme:</span>
<span class="sd">            - &#39;vasp&#39; sum of the data / number of grid points == number of electrons</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">structure</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">normalization</span> <span class="o">=</span> <span class="n">normalization</span>
    <span class="k">if</span> <span class="n">normalization</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;n&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        No rescaling</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scaled_data</span> <span class="o">=</span> <span class="n">grid_data</span>
    <span class="k">elif</span> <span class="n">normalization</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        the standard charge density from VASP is given as (rho*V) such that:</span>
<span class="sd">        sum(rho)/NGRID = NELECT/UC_vol</span>
<span class="sd">        so the real rho is:</span>
<span class="sd">        rho = (rho*UC_vol)*NGRID/UC_vol/UC_vol</span>
<span class="sd">        where the second V account for the different number of electrons in</span>
<span class="sd">        different cells</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scaled_data</span> <span class="o">=</span> <span class="n">grid_data</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">volume</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Not a valid normalization scheme&quot;</span><span class="p">)</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">grid_data</span><span class="o">=</span><span class="n">scaled_data</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="pyrho.core.chargeDensity.ChargeDensity.from_pmg_volumetric_data" class="doc doc-heading">
<code class="codehilite language-python"><span class="n">from_pmg_volumetric_data</span><span class="p">(</span><span class="n">vdata</span><span class="p">,</span> <span class="n">data_key</span><span class="o">=</span><span class="s1">&#39;total&#39;</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-classmethod"><code>classmethod</code></small>
  </span>

<a href="#pyrho.core.chargeDensity.ChargeDensity.from_pmg_volumetric_data" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Read a single key from the data field of a VolumetricData object</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>vdata</code></td>
        <td><code>VolumetricData</code></td>
        <td><p>The volumetric data object</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>data_key</code></td>
        <td><code></code></td>
        <td><p>The key to read from in the data field</p></td>
        <td><code>&#39;total&#39;</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>ChargeDensity</code></td>
      <td><p>ChargeDensity object</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>pyrho/core/chargeDensity.py</code></summary>
          <div class="codehilite"><pre><span></span><code><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">from_pmg_volumetric_data</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">,</span> <span class="n">vdata</span><span class="p">:</span> <span class="n">VolumetricData</span><span class="p">,</span> <span class="n">data_key</span><span class="o">=</span><span class="s2">&quot;total&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ChargeDensity&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read a single key from the data field of a VolumetricData object</span>
<span class="sd">    Args:</span>
<span class="sd">        vdata: The volumetric data object</span>
<span class="sd">        data_key: The key to read from in the data field</span>

<span class="sd">    Returns:</span>
<span class="sd">        ChargeDensity object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
        <span class="n">grid_data</span><span class="o">=</span><span class="n">vdata</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">data_key</span><span class="p">],</span>
        <span class="n">structure</span><span class="o">=</span><span class="n">vdata</span><span class="o">.</span><span class="n">structure</span><span class="p">,</span>
        <span class="n">normalization</span><span class="o">=</span><span class="s2">&quot;vasp&quot;</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>





  <div class="doc doc-object doc-method">



<h3 id="pyrho.core.chargeDensity.ChargeDensity.get_transformed_obj" class="doc doc-heading">
<code class="codehilite language-python"><span class="n">get_transformed_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sc_mat</span><span class="o">=</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">frac_shift</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">grid_out</span><span class="o">=</span><span class="mi">1000000000</span><span class="p">,</span> <span class="n">up_sample</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></code>


<a href="#pyrho.core.chargeDensity.ChargeDensity.get_transformed_obj" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Modify the structure and data and return a new object containing the reshaped
data</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>sc_mat</code></td>
        <td><code>Union[int, float, complex, str, bytes, numpy.generic, Sequence[Union[int, float, complex, str, bytes, numpy.generic]], Sequence[Sequence[Any]], numpy._array_like._SupportsArray]</code></td>
        <td><p>Matrix to create the new cell</p></td>
        <td><code>((1, 0, 0), (0, 1, 0), (0, 0, 1))</code></td>
      </tr>
      <tr>
        <td><code>frac_shift</code></td>
        <td><code>Union[int, float, complex, str, bytes, numpy.generic, Sequence[Union[int, float, complex, str, bytes, numpy.generic]], Sequence[Sequence[Any]], numpy._array_like._SupportsArray]</code></td>
        <td><p>translation to be applied on the cell after the matrix</p></td>
        <td><code>(0.0, 0.0, 0.0)</code></td>
      </tr>
      <tr>
        <td><code>grid_out</code></td>
        <td><code>Union[List[int], int]</code></td>
        <td><p>density of the new grid, can also just take the desired</p></td>
        <td><code>1000000000</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>ChargeDensity</code></td>
      <td></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>pyrho/core/chargeDensity.py</code></summary>
          <div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">get_transformed_obj</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">sc_mat</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
    <span class="n">frac_shift</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
    <span class="n">grid_out</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e9</span><span class="p">),</span>
    <span class="n">up_sample</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ChargeDensity&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Modify the structure and data and return a new object containing the reshaped</span>
<span class="sd">    data</span>
<span class="sd">    Args:</span>
<span class="sd">        sc_mat: Matrix to create the new cell</span>
<span class="sd">        frac_shift: translation to be applied on the cell after the matrix</span>
<span class="sd">        transformation</span>
<span class="sd">        grid_out: density of the new grid, can also just take the desired</span>
<span class="sd">        dimension as a list.</span>

<span class="sd">    Returns:</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_structure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">new_structure</span><span class="o">.</span><span class="n">translate_sites</span><span class="p">(</span>
        <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_structure</span><span class="p">))),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">frac_shift</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">new_structure</span> <span class="o">=</span> <span class="n">new_structure</span> <span class="o">*</span> <span class="n">sc_mat</span>

    <span class="c1"># determine the output grid</span>
    <span class="n">lengths</span> <span class="o">=</span> <span class="n">new_structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">abc</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid_out</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">ngrid</span> <span class="o">=</span> <span class="n">grid_out</span> <span class="o">/</span> <span class="n">new_structure</span><span class="o">.</span><span class="n">volume</span>
        <span class="n">mult</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span> <span class="o">/</span> <span class="n">ngrid</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">grid_out</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">l_</span> <span class="o">/</span> <span class="n">mult</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span> <span class="k">for</span> <span class="n">l_</span> <span class="ow">in</span> <span class="n">lengths</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">grid_out</span> <span class="o">=</span> <span class="n">grid_out</span>

    <span class="n">new_rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transformed_data</span><span class="p">(</span>
        <span class="n">sc_mat</span><span class="p">,</span> <span class="n">frac_shift</span><span class="p">,</span> <span class="n">grid_out</span><span class="o">=</span><span class="n">grid_out</span><span class="p">,</span> <span class="n">up_sample</span><span class="o">=</span><span class="n">up_sample</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">ChargeDensity</span><span class="o">.</span><span class="n">from_rho</span><span class="p">(</span><span class="n">new_rho</span><span class="p">,</span> <span class="n">new_structure</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalization</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-method">



<h3 id="pyrho.core.chargeDensity.ChargeDensity.reorient_axis" class="doc doc-heading">
<code class="codehilite language-python"><span class="n">reorient_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code>


<a href="#pyrho.core.chargeDensity.ChargeDensity.reorient_axis" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Change the orientation of the lattice vector so that:
a points along the x-axis, b is in the xy-plane, c is in the positive-z halve of space</p>

        <details class="quote">
          <summary>Source code in <code>pyrho/core/chargeDensity.py</code></summary>
          <div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">reorient_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Change the orientation of the lattice vector so that:</span>
<span class="sd">    a points along the x-axis, b is in the xy-plane, c is in the positive-z halve of space</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">abc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">angles</span>
    <span class="p">)</span>  <span class="c1"># type:  Tuple[float, float, float, float, float, float]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span> <span class="o">=</span> <span class="n">Lattice</span><span class="o">.</span><span class="n">from_parameters</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">vesta</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>





  </div>

    </div>

  </div>



  <div class="doc doc-object doc-class">



<h2 id="pyrho.core.chargeDensity.SpinChargeDensity" class="doc doc-heading">
        <code>SpinChargeDensity</code>



<a href="#pyrho.core.chargeDensity.SpinChargeDensity" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">





  <div class="doc doc-children">










  <div class="doc doc-object doc-method">



<h3 id="pyrho.core.chargeDensity.SpinChargeDensity.__init__" class="doc doc-heading">
<code class="codehilite language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chargeden_dict</span><span class="p">,</span> <span class="n">aug_charge</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

  <span class="doc doc-properties">
      <small class="doc doc-property doc-property-special"><code>special</code></small>
  </span>

<a href="#pyrho.core.chargeDensity.SpinChargeDensity.__init__" class="headerlink" title="Permanent link">&para;</a></h3>

    <div class="doc doc-contents ">

      <p>Wrapper class that parses multiple sets of grid data on the same lattice</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>chargeden_dict</code></td>
        <td><code>Dict</code></td>
        <td><p>A dictionary containing multiple charge density objects
        typically in the format {'total' : ChargeDen1, 'diff' : ChargeDen2}</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>pyrho/core/chargeDensity.py</code></summary>
          <div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chargeden_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">aug_charge</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper class that parses multiple sets of grid data on the same lattice</span>

<span class="sd">    Args:</span>
<span class="sd">        chargeden_dict: A dictionary containing multiple charge density objects</span>
<span class="sd">                    typically in the format {&#39;total&#39; : ChargeDen1, &#39;diff&#39; : ChargeDen2}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">chargeden_dict</span> <span class="o">=</span> <span class="n">chargeden_dict</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">aug_charge</span> <span class="o">=</span> <span class="n">aug_charge</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_key</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
        <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chargeden_dict</span><span class="p">)</span>
    <span class="p">)</span>  <span class="c1"># get one key in the dictionary to make writing the subsequent code easier</span>
</code></pre></div>
        </details>
    </div>

  </div>










  </div>

    </div>

  </div>




  <div class="doc doc-object doc-function">



<h2 id="pyrho.core.chargeDensity.multiply_aug" class="doc doc-heading">
<code class="codehilite language-python"><span class="n">multiply_aug</span><span class="p">(</span><span class="n">data_aug</span><span class="p">,</span> <span class="n">factor</span><span class="p">)</span></code>


<a href="#pyrho.core.chargeDensity.multiply_aug" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>The original idea here was to use to to speed up some vasp calculations for
supercells by initializing the entire CHGCAR file.
The current code does not deal with transformation of the Augemetation charges after regridding.</p>
<p>This is a naive way to multiply the Augmentation data in the CHGCAR,
a real working implementation will require analysis of the PAW projection operators.
However, even with such an implementation, the speed up will be minimal due to VASP's interal
minimization algorithms.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>data_aug</code></td>
        <td><code>List[str]</code></td>
        <td><p>The original augmentation data from a CHGCAR</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>factor</code></td>
        <td><code>int</code></td>
        <td><p>The multiplication factor (some integer number of times it gets repeated)</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>List[str]</code></td>
      <td><p>List of strings for each line of the Augmentation data.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>pyrho/core/chargeDensity.py</code></summary>
          <div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">multiply_aug</span><span class="p">(</span><span class="n">data_aug</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">factor</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The original idea here was to use to to speed up some vasp calculations for</span>
<span class="sd">    supercells by initializing the entire CHGCAR file.</span>
<span class="sd">    The current code does not deal with transformation of the Augemetation charges after regridding.</span>

<span class="sd">    This is a naive way to multiply the Augmentation data in the CHGCAR,</span>
<span class="sd">    a real working implementation will require analysis of the PAW projection operators.</span>
<span class="sd">    However, even with such an implementation, the speed up will be minimal due to VASP&#39;s interal</span>
<span class="sd">    minimization algorithms.</span>
<span class="sd">    Args:</span>
<span class="sd">        data_aug: The original augmentation data from a CHGCAR</span>
<span class="sd">        factor: The multiplication factor (some integer number of times it gets repeated)</span>
<span class="sd">    Returns:</span>
<span class="sd">        List of strings for each line of the Augmentation data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># type: List[str]</span>
    <span class="n">cur_block</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># type: List[str]</span>
    <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">ll</span> <span class="ow">in</span> <span class="n">data_aug</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;augmentation&quot;</span> <span class="ow">in</span> <span class="n">ll</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cur_block</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">factor</span><span class="p">):</span>
                    <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">cur_block</span><span class="p">[</span>
                        <span class="mi">0</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;augmentation occupancies</span><span class="si">{</span><span class="n">cnt</span><span class="si">:</span><span class="s2">&gt;4</span><span class="si">}{</span><span class="n">cur_block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">&gt;4</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">cur_block</span><span class="p">)</span>
            <span class="n">cur_block</span> <span class="o">=</span> <span class="p">[</span><span class="n">ll</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cur_block</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ll</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">factor</span><span class="p">):</span>
            <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">cur_block</span><span class="p">[</span>
                <span class="mi">0</span>
            <span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;augmentation occupancies</span><span class="si">{</span><span class="n">cnt</span><span class="si">:</span><span class="s2">&gt;4</span><span class="si">}{</span><span class="n">cur_block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">&gt;4</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">res</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">cur_block</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>
</code></pre></div>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="Footer">
      
        <a href="../../getting_started/jupyter_setup/" class="md-footer__link md-footer__link--prev" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              Jupyter Setup
            </div>
          </div>
        </a>
      
      
        <a href="../vis/" class="md-footer__link md-footer__link--next" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              vis
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Built by The Materials Project
          </div>
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../..", "features": [], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}, "search": "../../assets/javascripts/workers/search.fb4a9340.min.js", "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.ca5457b8.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>